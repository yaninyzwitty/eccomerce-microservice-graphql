package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"log/slog"

	"github.com/yaninyzwitty/new-galgrn-go/graph/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

// Products is the resolver for the products field.
func (r *categoryResolver) Products(ctx context.Context, obj *model.Category) ([]*model.Product, error) {
	panic(fmt.Errorf("not implemented: Products - products"))
}

// AddProduct is the resolver for the addProduct field.
func (r *mutationResolver) AddProduct(ctx context.Context, name string, price float64, categoryID string, stock int) (*model.Product, error) {

	catID, err := primitive.ObjectIDFromHex(categoryID)
	if err != nil {
		slog.Error("invalid category id")
		return nil, fmt.Errorf("invalid category id: %w", err)
	}

	// Fetch category from MongoDB
	var category model.Category
	err = r.MongoDBCategoriescollection.FindOne(ctx, bson.M{"_id": catID}).Decode(&category)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			slog.Error("category not found", "categoryID", categoryID)
			return nil, fmt.Errorf("category not found")
		}
		slog.Error("failed to fetch category", "error", err)
		return nil, fmt.Errorf("failed to fetch category: %w", err)
	}

	// Create the new product
	newMongoProduct := model.MongoProduct{
		ID:         primitive.NewObjectID(),
		Name:       name,
		Price:      price,
		Stock:      stock,
		CategoryID: catID,
	}

	// Insert the product into MongoDB
	result, err := r.MongoDBProductscollection.InsertOne(ctx, newMongoProduct)
	if err != nil {
		slog.Error("failed to insert product", "error", err)
		return nil, fmt.Errorf("failed to insert product: %w", err)
	}

	// Validate InsertedID as ObjectID
	insertedID, ok := result.InsertedID.(primitive.ObjectID)
	if !ok {
		slog.Error("unexpected ID type returned from InsertOne", "id", result.InsertedID)
		return nil, fmt.Errorf("unexpected ID type returned from InsertOne")
	}

	// Construct and return the GraphQL Product model
	return &model.Product{
		ID:       insertedID.Hex(),
		Name:     name,
		Price:    price,
		Category: &category,
		Stock:    stock,
	}, nil
}

// AddCategory is the resolver for the addCategory field.
func (r *mutationResolver) AddCategory(ctx context.Context, name string, description *string) (*model.Category, error) {
	// Safely handle the optional description
	var desc string
	if description != nil {
		desc = *description
	}

	// Construct the category data model
	newCategory := model.MongoCategory{
		ID:          primitive.NewObjectID(),
		Name:        name,
		Description: desc,
	}

	// Insert the new category into the database
	result, err := r.MongoDBCategoriescollection.InsertOne(ctx, newCategory)
	if err != nil {
		slog.Error("failed to insert category", "error", err)
		return nil, fmt.Errorf("failed to insert category: %w", err)
	}

	// Validate InsertedID as ObjectID
	insertedID, ok := result.InsertedID.(primitive.ObjectID)
	if !ok {
		slog.Error("unexpected ID type returned from InsertOne", "id", result.InsertedID)
		return nil, fmt.Errorf("unexpected ID type returned from InsertOne")
	}

	// Query products associated with the new category
	var products []*model.Product
	// Return the newly created category
	return &model.Category{
		ID:       insertedID.Hex(),
		Name:     name,
		Products: products,
	}, nil
}

// UpdateProductStock is the resolver for the updateProductStock field.
func (r *mutationResolver) UpdateProductStock(ctx context.Context, productID string, stock int) (*model.Product, error) {
	if stock < 0 {
		return nil, fmt.Errorf("stock cannot be negative")

	}

	// fetch existing product from repository
	productIDPrimitive, err := primitive.ObjectIDFromHex(productID)
	if err != nil {
		return nil, fmt.Errorf("invalid product id: %w", err)
	}

	var mongoProduct model.MongoProduct
	filter := bson.D{{Key: "_id", Value: productIDPrimitive}}
	if err := r.MongoDBProductscollection.FindOne(ctx, filter).Decode(&mongoProduct); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("product not found")
		}
		return nil, fmt.Errorf("failed to fetch product: %w", err)
	}
	// update product stock
	updatedProduct := mongoProduct
	updatedProduct.Stock = stock
	updateFilter := bson.D{{Key: "_id", Value: productIDPrimitive}}
	updateStock := bson.D{{Key: "$set", Value: bson.D{{Key: "stock", Value: stock}}}}
	result, err := r.MongoDBProductscollection.UpdateOne(ctx, updateFilter, updateStock)
	if err != nil {
		return nil, fmt.Errorf("failed to update product: %w", err)
	}
	if result.ModifiedCount == 0 {
		return nil, fmt.Errorf("product not found")
	}

	var mongoCategory model.Category
	if err := r.MongoDBCategoriescollection.FindOne(ctx, bson.M{"_id": mongoProduct.CategoryID}).Decode(&mongoCategory); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("category not found")
		}
		return nil, fmt.Errorf("failed to fetch category: %w", err)
	}

	return &model.Product{
		ID:       updatedProduct.ID.Hex(),
		Name:     updatedProduct.Name,
		Price:    updatedProduct.Price,
		Stock:    updatedProduct.Stock,
		Category: &mongoCategory,
	}, nil

}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.NewOrderInput) (*model.Order, error) {

	panic(fmt.Errorf("not implemented: Items - items"))

}

// Items is the resolver for the items field.
func (r *orderResolver) Items(ctx context.Context, obj *model.Order) ([]*model.OrderItem, error) {
	panic(fmt.Errorf("not implemented: Items - items"))
}

// Product is the resolver for the product field.
func (r *orderItemResolver) Product(ctx context.Context, obj *model.OrderItem) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: Product - product"))
}

// Category is the resolver for the category field.
func (r *productResolver) Category(ctx context.Context, obj *model.Product) (*model.Category, error) {
	catID, err := primitive.ObjectIDFromHex(obj.Category.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid category id: %w", err)
	}

	// Fetch the category from the database
	var category model.Category
	err = r.MongoDBCategoriescollection.FindOne(ctx, bson.M{"_id": catID}).Decode(&category)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("category not found")
		}
		return nil, fmt.Errorf("failed to fetch category: %w", err)
	}

	return &category, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, categoryID *string) ([]*model.Product, error) {
	if categoryID == nil {
		return nil, fmt.Errorf("categoryID is required")
	}

	catID, err := primitive.ObjectIDFromHex(*categoryID)
	if err != nil {
		return nil, fmt.Errorf("invalid category id: %w", err)
	}

	filter := bson.M{"category_id": catID}

	cursor, err := r.MongoDBProductscollection.Find(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch products: %w", err)
	}
	defer cursor.Close(ctx)

	var mongoProducts []*model.MongoProduct
	if err = cursor.All(ctx, &mongoProducts); err != nil {
		return nil, fmt.Errorf("failed to decode products: %w", err)
	}

	products := make([]*model.Product, len(mongoProducts))
	for i, mongoProduct := range mongoProducts {
		category := &model.Category{
			ID:   mongoProduct.CategoryID.Hex(),
			Name: mongoProduct.Name,
		}
		products[i] = &model.Product{
			ID:       mongoProduct.ID.Hex(),
			Name:     mongoProduct.Name,
			Price:    mongoProduct.Price,
			Category: category,
			Stock:    mongoProduct.Stock,
		}
	}

	return products, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	productId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, fmt.Errorf("invalid product id: %w", err)
	}
	var mongoProduct model.MongoProduct

	err = r.MongoDBProductscollection.FindOne(ctx, bson.M{"_id": productId}).Decode(&mongoProduct)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("product not found")
		}
		return nil, fmt.Errorf("failed to fetch product: %w", err)
	}

	// fetch category from mongodb
	var mongoCategory model.MongoCategory

	err = r.MongoDBCategoriescollection.FindOne(ctx, bson.M{"_id": mongoProduct.CategoryID}).Decode(&mongoCategory)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("category not found")
		}
		return nil, fmt.Errorf("failed to fetch category: %w", err)
	}

	category := &model.Category{
		ID:   mongoCategory.ID.Hex(),
		Name: mongoCategory.Name,
	}

	return &model.Product{
		ID:       mongoProduct.ID.Hex(),
		Name:     mongoProduct.Name,
		Price:    mongoProduct.Price,
		Category: category,
		Stock:    mongoProduct.Stock,
	}, nil

}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	panic(fmt.Errorf("not implemented: Categories - categories"))
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	panic(fmt.Errorf("not implemented: Orders - orders"))
}

// Category returns CategoryResolver implementation.
func (r *Resolver) Category() CategoryResolver { return &categoryResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Order returns OrderResolver implementation.
func (r *Resolver) Order() OrderResolver { return &orderResolver{r} }

// OrderItem returns OrderItemResolver implementation.
func (r *Resolver) OrderItem() OrderItemResolver { return &orderItemResolver{r} }

// Product returns ProductResolver implementation.
func (r *Resolver) Product() ProductResolver { return &productResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type categoryResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type orderResolver struct{ *Resolver }
type orderItemResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
